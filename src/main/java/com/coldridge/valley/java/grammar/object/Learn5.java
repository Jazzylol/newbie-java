package com.coldridge.valley.java.grammar.object;

/**
 * new 对象这个动作在内存中到底做了什么，整个过程需要了解
 */
public class Learn5 {

    /**
     *
     *
     * 首先java中 一个.java文件在程序里运行是要先要java编译器（javac命令）将文件编译成.class文件。
     * 编译成.class文件以后，jvm（java虚拟机）会将改.class文件导入到jvm中（导入的有不同的策略，大致分预先导入和使用时再导入）
     * jvm导入.class文件的时候会进行一些常规操作，例如 加载，验证格式是否正确，是否是自家编译器编译的，等等信息，最后就是抽象：
     * jvm会把所有的.class文件抽象为 一个类名为 Class为类，不同类型表现为泛型不同即  Class<A>  Class<B>等等，而java中规定同一个类的class
     * 文件只会在内存中存在一个，也就是说一个类只有一个对应的Class对象，而用这个class对象new出来的普通对象可以有无数多个
     *
     *
     *
     * 等待jvm把.class加载完毕，那么jvm中就包含了改类的class文件，而class文件抽象成对象以后就可以使用Class对象的一些基本功能了，比如新建对象
     * 所以 当new关键字触发的时候，底层调用的就是 对应的Class对象的新建对象方法（newInstance方法）
     *
     *
     * 之前我们说过静态变量 成员变量的区别，在整个加载过程中也有体现
     * 比如，之前说过静态变量（static修饰的变量）的生命周期是和.class文件相同的，是绑定在一起的。而成员变量则是跟一个个对象绑定在一起的
     * 所以 当.class文件加载到jvm这个过程中，就会触发静态变量和静态代码块等一切静态的东西的初始化，当class文件加载到jvm中加载完毕的时候
     * 静态变量 静态函数 肯定是已经初始化完毕的，这2个静态的东西就是在jvm加载class文件的时候进行初始化的。
     *
     * 而成员变量因为生命周期绑定在对象上，所以跟成员有关的 构造函数 构造代码块 都是在对象被新建的时候 初始化的。
     *
     * 这个也就解释了 为什么 静态的东西会比成员的东西 先执行。当然以上初始化的代码永远都只会执行一次。静态的初始化跟class文件绑定在一起，而class
     * 文件内存中只有一份，所以静态变量 代码块只会初始化一次。对象的初始化也只会初始化一次，但是new不同的对象的时候就会再次触发。对于同一个对象只会触发
     * 一次成员变量 构造函数 构造代码块的初始化
     *
     *
     *
     * 总结整个new关键字 触发的时候会做什么。
     * 1、jvm尝试找到这个对象对应的class文件，如果没有 2，存在转 5
     * 2、在环境变量（classpath）中寻找该class存不存在，不存在报错，存在转3
     * 3、尝试加载class文件到jvm中，期间对class文件做校验，签名格式，数据等等等等。加载过程出问题直接停止加载报错退出程序，成功转4
     * 4、成功加载对象对应的class文件以后，会把该class文件抽象成一个Class对象，并且初始化该对象内部所有的静态相关的变量，代码块等。
     * 5、使用该Class对象的newInstance方法创建对象
     * 6、对象创建成功，初始化对象内部数据，包括 构造代码块，构造函数，成员变量。初始化顺序依次从父类->子类。也就是父类的构造代码块先执行
     *      再父类的构造函数，父类成员变量再子类的构造代码块，构造函数，成员变量
     * 7、初始化完毕以后，对象创建成功，赋值内存地址给对应的变量引用。（赋值以及内存申请 到jvm内存结构再讲）
     */







}
